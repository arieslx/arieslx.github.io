---
title: 2025年｜前端内参复习
date: 2025-10-29 15:17:59
tags:
  - 2025
  - front-end-interview
  - 前端内参
---

## es新特性
### es7

```js

// 1. Array.prototype.includes
let arr = [1,2,NaN];
console.log(arr.includes(NaN)); // true
console.log(arr.indexOf(NaN) != -1) // false
console.log(arr.includes(1)); // true

// 2. 指数运算符

console.log(2**3) // 8

```

### es8

```js
// 1. Object.values
let obj1 = {x: 'xxx', y: 'yyy'}
Object.values(obj1)
// ['xxx', 'yyy']
let arr1 = ['e', 's', '8']
Object.values(arr1)
// ['e', 's', '8']
let obj2 = {10: 'xxx', 2: 'yyy', 1: 'zzz'}
Object.values(obj2)
// ['zzz', 'yyy', 'xxx']

// --
Object.entries(obj1); // [['x', 'xxx'], ['y', 1]]
Object.entries(arr1); // [['0', 'e'], ['1', 's'], ['2', '8']]
Object.entries(obj2); // [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]
Object.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']]

for (const [key, value] of Object.entries('es8')){
    console.log(key, value);
}

const values = Object.entries('es8').map(([k, v]) => v); // ['e', 's', '8']

Object.entries('es8').forEach(([key, value]) => {
  console.log(key, value);
});


// --

// 2. 字符串追加
'es8'.padStart(7, 0)
// '0000es8'
'es8'.padEnd(7, 0)
// 'es80000'

// 3. Object.getOwnPropertyDescriptors

let obj3 = {
    get es8(){}
}

Object.getOwnPropertyDescriptors(obj3)
// {
//   es8: {
//     configurable: true,
//     enumerable: true,
//     get: function es8(){}, //the getter function
//     set: undefined
//   }
// }

// 4. 结尾允许逗号
// 5. async/await
// 6. 共享内存和Atomics对象
```

### es9

```js
// 1. 异步迭代器
// 2. Promise.prototype.finally
// 3. 重新修订了字面量的转义
/**
ES9之前，\u表示 unicode 转义，\x表示十六进制转义，\后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如`Windows文件路径C:\uuu\xxx\111`。
要取消转义序列的语法限制，可在模板字符串之前使用标记函数String.raw。
**/
let s = `\u{54}` // 会转义成unicode "T"
console.log(s); //>> T

let str = String.raw`\u{54}`; // 不会被转义
console.log(str); // >> \u{54}

// 4. Rest / Spread(扩展运算符和rest参数)

```

### es10

```js

// 1. String.prototype.{trimStart,trimEnd}
// 2. Object.fromEntries
// 3. Array.prototype.{flat,flatMap}

```

### es11

```js

// 1. 可选链
let second = obj?.first?.second;

// 2. Nullish coalescing Operator(空值处理)
let a = 0; 
let v = a ?? "some value";
console.log(v); //>> 0
// 3. Promise.allSettled
// 4. Bigint
// 5. globalThis

```

## 函数

```js
// 1. 立即执行函数怎么递归
(function (i){
    console.log("函数名为"+func.name+",第"+i+"次调用")
    if(i<3){//递归出口
        arguments.callee(++i);
    }
})(1);
//>> 函数名为func,第1次调用
//>> 函数名为func,第2次调用
//>> 函数名为func,第3次调用

// 2. 箭头函数不暴露argument对象
// 箭头函数一个明显作用就是可以保持this的指向，总是指向定义它时所在的上下文环境。最后，箭头函数也没有自己的 super或new.target。

```

## this

1. this的指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的。
2. this 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）。
3. 正因为在执行上下文的创建阶段this的指向就已经被确定了，在执行阶段this指向不可再被更改。
4. this指向最靠近被调用函数的对象。
5. this显式指向：call、apply、 bind。

### 具体怎么判断好呢？

1. 函数是否在new 中被调用（new 操作符指向），如果是的话，this 绑定的是新创建的对象。
2. 函数是否被call、apply、bind 改变过this指向，如果是的话，this 绑定的是改变后的对象。
3. 函数是否被当做某个对象的方法而调用（隐式指向）？如果是的话，this指向的是这个对象。
4. 若以上都不是的话，使用默认绑定。
5. null或者undefined作为this指向的对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认指向规则。
6. this 默认指向window，但是严格模式下this指向undefined。隐式指向之隐式丢失
8. 函数是否被bind改变过this指向，如果是的话，this 绑定的是改变后的对象。
```js
function func() {
  console.log(this.a);
}
var a = 2;
var o = { a: 3, func: func };
var p = { a: 4 };
o.func(); //>> 3
(p.func = o.func)(); //>> 2
// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用
// 因此调用位置是 func() 而不是 p.func() 或者 o.func()
```

7. 箭头函数的this指向外部函数的this。被绑定之后无法修改。
```js
function func() {
  // 返回一个箭头函数
  return a => {
    //this 继承自 func()
    console.log(this.a);
  };
}
var obj1 = {
  a: 2
};
var obj2 = {
  a: 3
};

var bar = func.call(obj1);
bar.call(obj2); //>> 2         不是 3 ！

// func() 内部创建的箭头函数会捕获调用时 func() 的 this。
// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，
// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）
```

### call、apply、bind

```js

func.call(thisArg, param1, param2, ...)//func是个函数

func.apply(thisArg, [param1,param2,...])

func.bind(thisArg, param1, param2, ...)

// 返回值：
// call / apply：返回func 执行的结果 ；
// bind：返回func的拷贝，并拥有指定的this值和初始参数。

// 参数：
// thisArg(可选):
// func的this指向thisArg对象；
// 非严格模式下：若thisArg指定为null，undefined，则func的this指向window对象；
// 严格模式下：func的this为undefined；
// 值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean。
// param1，param2(可选): 传给func的参数。
// 如果param不传或为 null/undefined，则表示不需要传入任何参数.
// apply第二个参数为类数组对象，数组内各项的值为传给func的参数。

// *******必须是函数才能调用call/apply/bind
// ***** 类数组 arrayLike 可以通过下标进行调用，具有length属性，同时也可以通过 for 循环进行遍历。
// 但是需要注意的是：类数组无法使用 forEach、splice、push 等数组原型链上的方法
// 获取DOM节点的方法，使用arguments获取到的所有参数
let domNodes = Array.prototype.slice.call(document.getElementsByTagName("h1")); // 把类数组转换成数组 
// 1. 判断数据类型
function isType(data, type) {
  const typeObj = {
    "[object String]": "string",
    "[object Number]": "number",
    "[object Boolean]": "boolean",
    "[object Null]": "null",
    "[object Undefined]": "undefined",
    "[object Object]": "object",
    "[object Array]": "array",
    "[object Function]": "function",
    "[object Date]": "date", // Object.prototype.toString.call(new Date())
    "[object RegExp]": "regExp",
    "[object Map]": "map",
    "[object Set]": "set",
    "[object HTMLDivElement]": "dom", // document.querySelector('#app')
    "[object WeakMap]": "weakMap",
    "[object Window]": "window", // Object.prototype.toString.call(window)
    "[object Error]": "error", // new Error('1')
    "[object Arguments]": "arguments"
  };

  let name = Object.prototype.toString.call(data); // 借用Object.prototype.toString()获取数据类型
  let typeName = typeObj[name] || "未知类型"; // 匹配数据类型
  return typeName === type; // 判断该数据类型是否为传入的类型
}

console.log(
  isType({}, "object"), //>> true
  isType([], "array"), //>> true
  isType(new Date(), "object"), //>> false
  isType(new Date(), "date") //>> true
);

// 2. 类数组对象
var arrayLike = {
  0: "OB",
  1: "Koro1",
  length: 2
};

Array.prototype.push.call(arrayLike, "添加数组项1", "添加数组项2");

console.log(arrayLike);
//>> {"0":"OB","1":"Koro1","2":"添加数组项1","3":"添加数组项2","length":4}


// 3. 获取数组中的最大值和最小值
const arr = [15, 6, 12, 13, 16];
const max = Math.max.apply(Math, arr); // 16
const min = Math.min.apply(Math, arr); // 6
```

### call、apply应该用哪个？

call,apply的效果完全一样，它们的区别也在于
参数数量/顺序确定就用call，参数数量/顺序不确定的话就用apply。
考虑可读性：参数数量不多就用call，参数数量比较多的话，把参数整合成数组，使用apply。
参数集合已经是一个数组的情况，用apply，比如上文的获取数组最大值/最小值。

页面通信，一般传递回调函数的时候会容易丢失this的值


### 手写call、bind、apply

## 实现apply/call/bind

### apply
```js
/**
 * 用原生JavaScript实现apply
 */
Function.prototype.myApply = function(thisArg) {
  if (thisArg === null || thisArg === undefined) {
    thisArg = window;
  } else {
    thisArg = Object(thisArg);
  }

  //判断是否为【类数组对象】
  function isArrayLike(o) {
    if (
      o && // o不是null、undefined等
      typeof o === "object" && // o是对象
      isFinite(o.length) && // o.length是有限数值
      o.length >= 0 && // o.length为非负值
      o.length === Math.floor(o.length) && // o.length是整数
      o.length < 4294967296
    )
      // o.length < 2^32
      return true;
    else return false;
  }

  const specialMethod = Symbol("anything");
  thisArg[specialMethod] = this;

  let args = arguments[1]; // 获取参数数组
  let result;

  // 处理传进来的第二个参数
  if (args) {
    // 是否传递第二个参数
    if (!Array.isArray(args) && !isArrayLike(args)) {
      throw new TypeError(
        "第二个参数既不为数组，也不为类数组对象。抛出错误"
      );
    } else {
      args = Array.from(args); // 转为数组
      result = thisArg[specialMethod](...args); // 执行函数并展开数组，传递函数参数
    }
  } else {
    result = thisArg[specialMethod]();
  }

  delete thisArg[specialMethod];
  return result; // 返回函数执行结果
};

Function.prototype.apply = function(thisArg, argsArray){
  if(typeof this !== 'function'){
    throw new TypeError('Function.prototype.apply called on non-function')
  }

  if(thisArg === undefined || thisArg === null){
    thisArg = window;
  }else{
    thisArg = Object(thisArg)
  }

  const func = Symbol('func');
  thisArg[func] = this;

  let result;

  if(argArray && typeof argArray === 'obejct' && 'length' in argsArray){
    result = thisArg[func](...Array.from(argsArray))
  } else if(argsArray && undefined || argsArray === null){
    result = thisArg[func]()
  } else {
    throw new TypeError('argsArray must be an array-like object')
  }

  delete thisArg(func)

  return result;
}


```

### call

```js
Function.prototype.call = function(thisArg, ...argsArray){
  if(typeof this !== 'function'){
    throw new TypeError('function.prototype.call called on non-function')
  }

  if(thisArg === undefined || thisArg === null){
    thisArg = window;
  } else {
    thisArg = Object(thisArg)
  }

  const func = Symbol('func');

  thisArg[func] = this;

  let result;
  if(argsArray.length){
    result = thisArg[func](...argsArray)
  }else{
    result = thisArg[func]()
  }

  delete thisArg[func];

  return result;
}

```

### bind

```js
Function.prototype.bind = function(thisArg, ...argsArray){
  if(typeof this !== 'function'){
    throw new TypeError('function.prototype.bind called on non-function')
  };

  if(thisArg === undefined || thisArg === null){
    thisArg = window;
  }else{
    thisArg = Object(thisArg)
  }

  const func = this;

  const bound = function(...boundArgsArray){
    let isNew = false;

    try{
      isNew = this instanceof func;
    }catch(e){

    }

    return func.apply(isNew ? this: thisArg, argsArray.concat(boundArgsArray))
  }

  const Empty = function(){}
  Empty.prototype = this.prototype;
  bound.prototype = new Empty();

  return bound;
}


/**
 * 用原生JavaScript实现bind
 */
Function.prototype.myBind = function(objThis, ...params) {
  const thisFn = this;//存储调用函数，以及上方的params(函数参数)
  //对返回的函数 secondParams 二次传参
  let funcForBind = function(...secondParams) {
    //检查this是否是funcForBind的实例？也就是检查funcForBind是否通过new调用
    const isNew = this instanceof funcForBind;

    //new调用就绑定到this上,否则就绑定到传入的objThis上
    const thisArg = isNew ? this : Object(objThis);

    //用call执行调用函数，绑定this的指向，并传递参数。返回执行结果
    return thisFn.call(thisArg, ...params, ...secondParams);
  };

  //复制调用函数的prototype给funcForBind
  funcForBind.prototype = Object.create(thisFn.prototype);
  return funcForBind;//返回拷贝的函数
};
```



---
title: 2025年｜还是一些来自前端内参的编码题目
date: 2025-11-12 17:17:59
tags:
  - 2025
  - front-end-interview
---

## call，apply，bind函数

```js
// 帮我实现一个leetcode上两数之和的题目



```

### 常见面试题
```js
for(var i=0;i<=5;i++){
  setTimeout(function(i){
    console.log(i)
  }.bind(null, i), i*1000)
}

```

### javascript手写call，apply，bind函数，尤其是bind函数

```js

Function.prototype.myCall = function(thisArg, ...arr){
  if(thisArg === null || thisArg === undefined){
    thisArg = window;
  } else {
    thisArg = Object(thisArg);
  }

  const specialMethod = Symbol('anything');
  thisArg[specialMethod] = this;
  let result = thisArg[specialMethod](...arr);

  delete thisArg[specialMethod];
  return result;
};

let obj = {
  name: "coffe1891"
};

function func(){
  console.log(this.name)
}

func.myCall(obj)

Function.prototype.myApply = function(thisArg){
  if(thisArg === null || thisArg === undefined){
    thisArg = window;
  } else {
    thisArg = Object(thisArg)
  }

  function isArrayLike(obj){
    if(o && typeof o === "object" && isFinite(o.length) && o.length >= 0 && o.length === Math.floor(o.length) && o.length < 4294967296)
    return true;
  else return false
  }

  const specialMethod = Symbol("anything")
  thisArg[specialMethod] = this;

  let args = arguments[1]
  let result;

  if(args){
    if(!Array.isArray(args) && !isArrayLike(args)){
      throw new TypeError("args must be an array-like object")
    } else{
      args = Array.from(args);
      result = thisArg[specialMethod](...args);
  } else {
    result = thisArg[speacialMethod]
  }
  delete thisArg[specialMethod]
  return result;
}

Function.prototype.myBind = function(objThis, ...params){
  const thisFn = this;
  let funcForBind = function(...secondParams){
    const isNew = this instanceof funcForBind;
    const thisArg = isNew ? this : objThis;
    return thisFn.call(thisArg, ...params, ...secondParams)
  };

  funcForBind.prototype = Object.create(thisFn.prototype)
  return funcForBind;
}

let func = function(p,secondParams){//其实测试用的func其参数可以是任意多个
    console.log(p.name);
    console.log(this.name);
    console.log(secondParams);
}
let obj={
    name:"1891"
}
func.myBind(obj,{name:"coffe"})("二次传参");
//>> coffe
//>> 1891
//>> 二次传参

```

## 循环

### for，forEach，map
如果使用箭头函数表达式来传入thisArg 参数会被忽略，因为箭头函数在词法上绑定了`this`值。
for循环满足特定条件时跳出循环体，或者跳出本次循环直接进入下一次循环。

### reduce
`initialValue`可选作为第一次调用`callback`函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素（也即针对数组的arr循环计算少一次，千万要注意这点）。 在没有初始值的空数组上调用`reduce`将报错。

数组—->对象

```js

const arr  = [
    {
        username:    'makai',
        displayname: '馆长',
        email:       'guanzhang@coffe1891.com'
    },
    {
        username:    'xiaoer',
        displayname: '小二',
        email:       'xiaoer@coffe1891.com'
    },
    {
        username:    'zhanggui',
        displayname: '掌柜',
        email:       null
    },
];

function cb1(acc, person){
  return {...acc, [person.username]: person}
}
const obj = arr.reduce(cb1, {})

```

## 深拷贝

缺点：
- 会忽略`undefined`；
- 会忽略`symbol`；
- 如果对象的属性为`Function`，因为JSON格式字符串不支持`Function`，在序列化的时候会自动删除；
- 诸如 `Map`, `Set`, `RegExp`, `Date`, `ArrayBuffer`和其他内置类型在进行序列化时会丢失；
- 不支持循环引用对象的拷贝。
```js
let a = {x: 2}
let b = JSON.sringiy(a)
```

缺点：
对象嵌套层次超过2层，就会出现浅拷贝的状况；
非可枚举的属性无法被拷贝。
```js
let a = {x:3}
let b = Object.assign({}, a)

```

缺点：
这个方法是异步的；
拷贝有函数的对象时，还是会报错。

```js

// 有undefined + 循环引用
let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
  f: undefined
}

obj.c = obj.b;
obj.e = obj.a;
obj.b.c = obj.c;
obj.b.d = obj.b;
obj.b.e = obj.b.c;

function deepClone(obj){
  return new Promise((resolve) => {
    const {port1, port2} = new MessageChannel();
    port2.onmessage = ev => resolve(ev.data);
    port1.postMessage(obj);
  })
}


deepClone(obj).then((copy) => {
  let copyObj = copy;
  console.log(copyObj, obj)
  console.log(copyObj == obj)
})
```

```js

function deepClone(obj, parent = null){
  let result = {};
  let keys = Object.keys(obj),
      key = null,
      temp = null,
      _parent = parent;
  while(_parent){
    if(_parent.originalParent === obj){
      return _parent.currentParent
    }
    _parent = _parent.parent
  }

  for(let i=0; i<keys.length; i++){
    key = keys[i];
    temp = obj[key]
    if(temp && typeof temp === 'object'){
      result[key] = deepClone(temp, {
        originalParent: obj,
        currentParent: result,
        parent: parent
      });
    }else{
      result[key] = temp
    }
  }
  return result;
}

```

```js

function deepClone(obj){
  let map = new WeakMap();
  function dp(obj){
    let result = null;
    let keys = null,
    key = null,
    temp = null,
    existsObj = null;

    existObj = map.get(obj)
    if(existObj){
      reurn existObj
    }
    keys = Object.keys(obj);
    result = {};
    map.set(obj, result);
    for(let i=0; i<keys.length; i++){
      key = keys[i];
      temp = obj[key];
      if(temp && typeof temp === 'object'){
        result[key] = dp(temp)
      }else{
        result[key] = temp;
      }
    }
    return result;

return dp(obj)
  }
}


```


终极方案是lodash的cloneDeep。
```js

_cloneDeep({xx:11})


```

## 柯里化

bind的柯里化
```js 
Function.prototype.bind = function(context){
  let _this = this;
  let args = Array.prototype.slice.call(arguments, 1)
  return function(){
    return _this.apply(context, args)
  }
}
```
给定一个函数fn，设计一个通用封装（currying函数）作用于这个fn，让这个fn可以支持柯里化，该怎么实现呢？思路：

要让fn(a,b)等价于fn(a)(b)，那么fn(a)要返回一个函数，这个函数接受参数b，并返回与fn(a,b)相同的结果。

设计一个currying函数，它接受第一个参数是要被柯里化的函数fn，第2~N个参数是原本要传递给fn的参数（这个可用rest操作符实现）。

柯里化主要围绕“处理参数”思考，不管怎么变化传参形式，柯里化之后的函数要把之前函数的参数都统统处理完毕才算合格。

```js

let promaryCurrying = function(fn, length){

  length = length || fn.length;

  return function(...args2){

    if(args2.length < length){
      var combinedArgs = [fn].concat(args2)

      return curry(primaryCurrying.apply(this, coombinedArgs), length - args2.length);
    }

    else {
      return fn.apply(this, args2)
    }
    
  };
}


```

// 实现一个add方法，使计算结果能够满足如下预期：
add(1)(2)(3) = 6;
add(1, 2, 3)(4) = 10;
add(1)(2)(3)(4)(5) = 15;

```js

function add(){
  var _args = Array.prototype.slice.call(arguments);
  var _addr = function(){
    _args.push(...arguments)
    return _addr;
  }

  _adder.toString = function(){
    return _args.reduce(function (acc, cur){
      return acc + cur;
    }, 0)
  }
  return _adder;
}


```

## reflect和proxy
### 数据绑定和响应式
```js

function createReactive(obj){
  return new Proxy(obj, {
    get(target, prop){
      console.log('reading'+ prop)
      return target[prop]
    },
    set(target, prop, value){
      console.log('setting', value)
      target[prop] = value;
      return true;
    }
  });
}

const data = createReactive({ count: 0 });
data.count;
data.count = 1


```

### 日志记录
```js
function createLoggingProxy(obj){
  return new Proxy(obj, {
    get(target, prop){
      console.log('get', [prop])
      return target[prop]
    }
    set(target, prop, value){
      console.log(`setting ${prop} = ${value}`)
      return Reflect.set(target, prop, value)
    }
  });
}

```

### 权限控制
```js
function createSecureProxy(obj, allowedProps){
  return new Proxy(obj, {
    get(target, prop) {
      if(allowedProps.includes(prop)){
        return target[prop]
      }
      throw new Error(`Not allowed to access ${prop}`)
    }
  })
}

```


